#Windows #ShellCode

> [!NOTE] 
> This is notes from [Ring 0x00](https://idafchev.github.io/blog/writing_windows_shellcode/) website
### Table of Contents
- [[#Introduction]]
- [[#Find the DLL Base Address]]
- [[#Appendix]]
	- [[#Thread Local Storage]]
	- [[#Understanding Concepts of Virtual Address (VA), Relative Virtual Address (RVA) and File Offsets]]
	- [[#Introduction to PE Structure]]
- [[#References]]
## Introduction
This tutorial is for `x86 32bit` shellcode. Windows shellcode is a lot harder to write than the shellcode for Linux and you’ll see why. First we need a basic understanding of the Windows architecture, which is shown below. Take a good look at it. Everything above the dividing line is in User mode and everything below is in Kernel mode.

![[Pasted image 20250212202106.png]]

Unlike Linux, in Windows, applications can’t directly accesss system calls. Instead they use functions from the `Windows API (WinAPI)`, which internally call functions from the `Native API (NtAPI)`, which in turn use system calls. The `Native API` functions are undocumented, implemented in `ntdll.dll` and also, as can be seen from the picture above, the lowest level of abstraction for User mode code.

The documented functions from the `Windows API` are stored in `kernel32.dll`, `advapi32.dll`, `gdi32.dll` and others. The base services (like working with file systems, processes, devices, etc.) are provided by `kernel32.dll`.

So to write shellcode for Windows, we’ll need to use functions from `WinAPI` or `NtAPI`. But how do we do that?

`ntdll.dll` and `kernel32.dll` are so important that they are imported by every process.

To demonstrate this I used the tool [ListDlls](https://docs.microsoft.com/en-us/sysinternals/downloads/listdlls) from the [sysinternals suite](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite).

The first four DLLs that are loaded by *explorer.exe*:  

![loaded_dlls1](https://idafchev.github.io/blog/assets/images/windows_shellcode/loaded_dlls1.png)

The first four DLLs that are loaded by *notepad.exe*:  

![loaded_dlls2](https://idafchev.github.io/blog/assets/images/windows_shellcode/loaded_dlls2.png)

I also wrote a little assembly program that does nothing (infinite empty loop) and it has 3 loaded DLLs:  

![loaded_dlls3](https://idafchev.github.io/blog/assets/images/windows_shellcode/loaded_dlls3.png)

Notice the base addresses of the DLLs. They are the same across processes, because they are loaded only once in memory and then referenced with pointer/handle by another process if it needs them. This is done to preserve memory. But those addresses will differ across machines and across reboots.

This means that the shellcode must find where in memory the DLL we’re looking for is located. Then the shellcode must find the address of the exported function, that we’re going to use.

The shellcode I’m going to write is going to be simple and its only function will be to execute `calc.exe`. To accomplish this I’ll make use of the [WinExec](https://msdn.microsoft.com/en-us/library/windows/desktop/ms687393.aspx) function, which has only two arguments and is exported by `kernel32.dll`.

## Find the DLL Base Address
It's well known that shellcode usually leverages the following chain of internal Windows OS memory structures in order to resolve the kernel32 base address which I am going to walk through in WinDBG:

```
TEB->PEB->Ldr->InMemoryOrderLoadList->currentProgram->ntdll->kernel32.BaseDl
```

One important thing to keep in mind is that _kernel32.dll_ is **always loaded into the same address for all the processes** - regardless if you open a calc.exe, notepad.exe, or any other Windows process. Below shows two different programs - in both cases, the kernel32.dll (and ntdll...) got loaded into the same memory address:

![[Pasted image 20250217012145.png]]

[Thread Environment Block (TEB)](https://en.wikipedia.org/wiki/Win32_Thread_Information_Block) is a structure which is unique for every [[#Thread Local Storage|thread]], resides in memory and holds information about the [[#Thread Local Storage|thread]]. The address of `TEB` is held in the `FS` segment register.

> [!info] What is FS?
>- `FS`is a **segment register** in x86 architecture (use in Intel and AMD CPUs
>- In Windows, the `FS register`point to the **Thread Environment Block (TEB)**, which is a data structure that holds informations about the current thread.
>- It's commonly used to access **thread-specific data**, like **Process Environment Block (PEB)** or **Thread Local Storage (TLS)**.

One of the fields of `TEB` is a pointer to [Process Environment Block (PEB)](https://en.wikipedia.org/wiki/Process_Environment_Block) structure, which holds information about the process. The pointer to `PEB` is `0x30` bytes after the start of `TEB`.

`0x0C` bytes from the start, the `PEB` contains a pointer to [PEB_LDR_DATA](https://www.nirsoft.net/kernel_struct/vista/PEB_LDR_DATA.html) structure, which provides information about the loaded DLLs. It has pointers to three doubly linked lists, two of which are particularly interesting for our purposes:
- `InInitializationOrderModuleList` which holds the DLLs in order of their initialization.
- `InMemoryOrderModuleList` which holds the DLLs in the order they appear in memory.

A pointer to the latter is stored at `0x14` bytes from the start of `PEB_LDR_DATA` structure. The base address of the DLL is stored `0x10` bytes below its list entry connection.

In the pre-Vista Windows versions the first two DLLs in `InInitializationOrderModuleList` were `ntdll.dll` and `kernel32.dll`, but for Vista and onwards the second DLL is changed to `kernelbase.dll`.

The second and the third DLLs in `InMemoryOrderModuleList` are `ntdll.dll` and `kernel32.dll`. This is valid for all Windows versions (at the time of writing (*26/7/2017*)) and is the preferred method, because it’s more portable.

So to find the address of `kernel32.dll` we must traverse several in-memory structures. The steps to do so are:
1. Get address of `PEB` with `fs:0x30`
2. Get address of `PEB_LDR_DATA` ([[#File Offset|offset]] `0x0C`)
3. Get address of the first list entry in the `InMemoryOrderModuleList` (offset `0x14`)
    (At this point is important to note that each entry in this list contain a pointer to the next entry)
4. Get address of the second (`ntdll.dll`) list entry in the `InMemoryOrderModuleList` (offset `0x00`)
5. Get address of the third (`kernel32.dll`) list entry in the `InMemoryOrderModuleList` (offset `0x00`)
6. Get the base address of `kernel32.dll` (offset `0x10`)

The assembly to do this is:

``` nasm
mov eax, fs:0x30	   ; 1. Get pointer to PEB
mov eax, [eax + 0x0C]  ; 2. Get pointer to PEB_LDR_DATA
mov eax, [eax + 0x14]  ; 3. Get pointer to first entry in InMemoryOrderModuleList
mov eax, [eax]		   ; 4. Get pointer to second (ntdll.dll) entry in InMemoryOrderModuleList
mov eax, [eax]		   ; 5. Get pointer to third (kernel32.dll) entry in InMemoryOrderModuleList
mov eax, [eax + 0x10]  ; 6. Get kernel32.dll base address
```

> [!question] Understanding the First Line
> - `mov eax, fs:0x30` loads the **Process Environment Block (PEB) pointer** into `eax`.   
> - In **Windows user-mode applications**, the **Thread Information Block (TIB)** (also called the **Thread Environment Block, TEB**) is located at `fs:[0]`.
> - The colon `:` specifies a segment override, meaning "read from the `fs` segment at offset `0x30`"
> ###### Why use `fs` insted `ds`?
> The reason why `fs` is used instead of `ds` (the default data segment) is because **Windows uses the FS segment register to store thread-specific information**, including the **Thread Environment Block (TEB)**, which contains a pointer to the **Process Environment Block (PEB)**.

They say a picture is worth a thousand words, so I made onde to illustrate the process. You can also access it using that [link](https://idafchev.github.io/blog/assets/images/windows_shellcode/locate_dll.png) to better view.

![[Pasted image 20250216213344.png]]

If a picture is worth a thousand words, then an animation is worth $(number\_of\_frames \times 1000) \times words$. 


> [!NOTE] Split Gifs
> You can split the GIF frame by frame in this [link](https://ezgif.com/split)


![[locate_dll1.gif]]
[link](https://idafchev.github.io/blog/assets/images/windows_shellcode/locate_dll1.gif)

![[locate_dll2.gif]]
[link](https://idafchev.github.io/blog/assets/images/windows_shellcode/locate_dll2.gif)
## Find the Function Address
Now that we have the base address of `kernel32.dll`, it’s time to find the address of the `WinExec`function. To do this we need to traverse several headers of the DLL. You should get familiar with the format of a [[#Introduction to PE Structure|PE executable file]]. Play around with [PEView](http://wjradburn.com/software/) and check out some [great illustrations of file formats](https://github.com/corkami/pics/tree/master/binary).

> [!NOTE] PE EXECUTABLE (PE)
> The **Portable Executable** (**PE**) format is a [file format](https://en.wikipedia.org/wiki/File_format "File format") for [executables](https://en.wikipedia.org/wiki/Executable "Executable"), [object code](https://en.wikipedia.org/wiki/Object_file "Object file"), [dynamic-link-libraries](https://en.wikipedia.org/wiki/Dynamic-link_library "Dynamic-link library") (DLLs), and binary files used on 32-bit and 64-bit [Windows](https://en.wikipedia.org/wiki/Microsoft_Windows "Microsoft Windows") [operating systems](https://en.wikipedia.org/wiki/Operating_system "Operating system"), as well as in [UEFI](https://en.wikipedia.org/wiki/UEFI "UEFI") environments. It is the standard format for executables on Windows NT-based systems, including files such as `.exe`, `.dll`, `.sys` (for system drivers), and `.mui`.
> Read more at [Wikipedia](https://en.wikipedia.org/wiki/Portable_Executable) or in [[#Introduction to PE Structure]].

In the PE format, at a constant [[#Understanding Concepts of Virtual Address (VA), Relative Virtual Address (RVA) and File Offsets|RVA]] of `0x3C` bytes is stored the RVA of the `PE signature` which is equal to `0x5045`.  
- `0x78` bytes after the `PE signature` is the RVA for the `Export Table`.  
- `0x14` bytes from the start of the `Export Table` is stored the number of functions that the DLL exports. 
- `0x1C` bytes from the start of the `Export Table` is stored the RVA of the `Address Table`, which holds the function addresses.  
- `0x20` bytes from the start of the `Export Table` is stored the RVA of the `Name Pointer Table`, which holds pointers to the names (strings) of the functions.  
- `0x24` bytes from the start of the `Export Table` is stored the RVA of the `Ordinal Table`, which holds the position of the function in the `Address Table`.

So to find `WinExec` we must:

1. Find the RVA of the `PE signature` (base address + `0x3C` bytes)
2. Find the address of the `PE signature` (base address + RVA of `PE signature`)
3. Find the RVA of `Export Table` (address of `PE signature` + `0x78` bytes)
4. Find the address of `Export Table` (base address + RVA of `Export Table`)
5. Find the number of exported functions (address of `Export Table` + `0x14` bytes)
6. Find the RVA of the `Address Table` (address of `Export Table` + `0x1C`)
7. Find the address of the `Address Table` (base address + RVA of `Address Table`)
8. Find the RVA of the `Name Pointer Table` (address of `Export Table` + `0x20` bytes)
9. Find the address of the `Name Pointer Table` (base address + RVA of `Name Pointer Table`)
10. Find the RVA of the `Ordinal Table` (address of `Export Table` + `0x24` bytes)
11. Find the address of the `Ordinal Table` (base address + RVA of `Ordinal Table`)
12. Loop through the `Name Pointer Table`, comparing each string (name) with `WinExec` and keeping count of the position.
13. Find `WinExec` ordinal number from the `Ordinal Table` (address of `Ordinal Table` + (position * 2) bytes). Each entry in the `Ordinal Table` is 2 bytes.
14. Find the function RVA from the `Address Table` (address of `Address Table` + (ordinal_number * 4) bytes). Each entry in the `Address Table` is 4 bytes.
15. Find the function address (base address + function RVA)

I doubt anyone understood this, so I again made some animations.

![[locate_function1.gif]]

And from [PEView](http://wjradburn.com/software/) to make it even more clear:

1. Open [PEView](http://wjradburn.com/software/)
2. Open the file `C:\Windows\SysWOW64`\kernel32.dll`
3. On the top bar, select *View -> Address -> Relative Virtual Address*
4. Now, in *IMAGE_DOS_HEADER* you can see at RVA `0x0000003C` the offset of New EXE Header
5. 




![[locate_function2.gif]]


## Appendix
### Thread Local Storage
A a **thread** refers to a sequence of instructions that can be executed independently by a CPU core. Threads are part of a process, and a single process can have multiple threads running concurrently. Each thread shares the same memory space and resources of the process it belongs to, but it has its own **stack** and **Thread Local Storage (TLS)**.

TLS is a mechanism that allows each thread to have its own private storage for data. This is useful when you want to store data that is specific to a thread and should not be shared with other threads. For example, in a multi-threaded program, each thread might need its own copy of a variable to avoid conflicts or race conditions.

In the context of the **FS segment** (a segment register in x86 architecture), the FS register is often used to point to the base address of the TLS for the current thread. This allows the program to access thread-specific data efficiently.
#### Thread in Operation System
A thread is a single sequence stream within a process ([Geek for Geek](https://www.geeksforgeeks.org/thread-in-operating-system/)). Threads are also called  **lightweight processes** as they possess some of the properties of processes. Each thread belongs to exactly one process.
- In an operating system that supports multithreading, the process can consist of many threads. But threads can be effective only if the CPU is more than 1 otherwise two threads have to context switch for that single CPU.
- All threads belonging to the same process share – code section, data section, and OS resources (e.g. open files and signals)
- But each thread has its own (thread control block) – thread ID, program counter, register set, and a stack
- Any operating system process can execute a thread. we can say that single process can have multiple threads.
#### Why do We Need Thread?
- Threads run in parallel improving the application performance. Each such thread has its own CPU state and stack, but they share the address space of the process and the environment.
- Threads can share common data so they do not need to use [inter-process communication](https://www.geeksforgeeks.org/inter-process-communication-ipc). Like the processes, threads also have states like ready, executing, blocked, etc. 
- Priority can be assigned to the threads just like the process, and the highest priority thread is scheduled first.
- Each thread has its own [Thread Control Block (TCB)](https://www.geeksforgeeks.org/thread-control-block-in-operating-system). Like the process, a context switch occurs for the thread, and register contents are saved in (TCB). As threads share the same address space and resources, synchronization is also required for the various activities of the thread.
#### Components of Threads
These are the basic components of the Operating System:
- **Stack Space:** Stores local variables, function calls, and return addresses specific to the thread.
- **Register Set:** Hold temporary data and intermediate results  for the thread's execution.
- **Program Counter:** Tracks the current instruction being executed by the thread.
#### Types of Thread in Operating System
Threads are of two types. These are described below.
- User Level Thread 
- Kernel Level Thread

![[Pasted image 20250216170926.png]]

##### 1. User Level Thread
**User Level Thread** is a type of thread that **is not created using system calls**. The kernel has no role in the management of user-level threads. User-Level threads can be easily implemented by the user. In case when user-level threads are single-threaded processes (processes that has only one thread of execution) kernel-level thread manages them.
###### Advantages of User-Level Threads
- Implementation of the User-Level Thread is easier than Kernel Level Thread.
- [Context Switch](https://www.geeksforgeeks.org/context-switch-in-operating-system) Time is less in User Level Thread.
- User-Level Thread is more efficient than Kernel-Level Thread.
- Because of the presence of only Program Counter, Register Set, and Stack Space, it has a simple representation.
###### Disadvantages of User-Level Threads
- The operating system is unaware of user-level threads, so kernel-level optimizations, like load balancing across CPUs, are not utilized.
- If a user-level thread makes a blocking system call, the entire process (and all its threads) is blocked, reducing efficiency.
- User-level thread scheduling is managed by the application, which can become complex and may not be as optimized as kernel-level scheduling.
##### 2. Kernel Level Threads
A [Kernel Level Thread](https://www.geeksforgeeks.org/kernel-level-threads-in-operating-system) is a type of thread that can recognize the Operating system easily. Kernel Level Threads has its own thread table where it keeps track of the system. The operating System Kernel helps in managing threads. Kernel Threads have somehow longer context switching time. Kernel helps in the management of threads.
###### Advantages of Kernel-Level Threads
- Kernel-level threads can run on multiple processors or cores simultaneously, enabling better utilization of multicore systems.
- The kernel is aware of all threads, allowing it to manage and schedule them effectively across available resources.
- Applications that block frequency are to be handled by the Kernel-Level Threads.
- The kernel can distribute threads across CPUs, ensuring optimal load balancing and system performance.
###### Disadvantages of Kernel-Level Threads
- Context switching between kernel-level threads is slower compared to user-level threads because it requires mode switching between user and kernel space.
- Managing kernel-level threads involves frequent system calls and kernel interactions, leading to increased CPU overhead.
- A large number of threads may overload the kernel scheduler, leading to potential performance degradation in systems with many threads.
- Implementation of this type of thread is a little more complex than a user-level thread.

> For more, refer to the [Difference Between User-Level Thread and Kernel-Level Thread](https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread).
#### Difference Between Process and Thread
The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces. Threads are not independent of one another like processes are, and as a result, threads share with other threads their code section, data section, and OS resources (like open files and signals). But, like a process, a thread has its own [program counter (PC)](https://www.geeksforgeeks.org/what-is-program-counter), register set, and stack space.

> For more, refer to [Difference Between Process and Thread](https://www.geeksforgeeks.org/difference-between-process-and-thread).

---
### Understanding Concepts of Virtual Address (VA), Relative Virtual Address (RVA) and File Offsets
Before we proceed to the concept of PE File Format, which describes the internal structure of all Windows executable files, one should also know the concepts of **Virtual Address (VA)**, **Relative Virtual Address (RVA)** and **File Offsets** as these would be the foundation in helping you to understand the technical parts of the PE file format.
#### Virtual Address (VA)
Applications do not directly access physical memory, they only access virtual memory. In other words, the Virtual Addresses (VAs) are the memory addresses that are referenced by an application.

Virtualizing access to memory provides flexibility in the way applications use available physical memory. In fact, an application doesn’t have to occupy a contiguous piece of physical memory; it can be broken down into parts, without the application even needing to know about it.
#### Relative Virtual Address (RVA)
In few words, we can say that Relative Virtual Address (RVA) is an address relative to the base address of the PE executable, when its loaded in memory.

**RVA is the difference between two Virtual Addresses (VA) and represents the highest one**. Virtual Address is the original address with respect to the *ImageBase*. *ImageBase* here means the base address where the executable file is first loaded into memory.  

> [!warning] Title
>  RVAs are not equal to the file offsets when the executable is on disk!

We can calculate RVA by the following equation:
$$
R\ VA = VA - ImageBase
$$
Let's see an example:

An Application is loaded into the memory having a Base Address at `0x400000`and the VA is at `0x401000`. So the RVA is calculated as 

$$
R\ VA = VA - ImageBase \implies R\ VA= 401000_{16}-400000_{16}
$$
$$
\therefore R\ VA=00001000_{16}
$$
#### File Offset
When we talk about offsets, we usually either refer to physical memory, a physical file on disk or in another general in cases where we treat data as raw data.

The file offset is actually a location within that particular file. To make it easier for you to understand, it is actually the distance from the starting point either the start of the file or the start of a memory address (It tells you where specific data or structures are located within the file). The offset value is added to the base value to determine the actual value.

 For example, if a file has a header at offset `0x100`, it means the header starts 256 bytes (0x100 in hexadecimal) from the start of the file.
 
So, if we have to calculate the file offset of the entry point in a [[#Introduction to PE Structure|PE file]], consider the below table which shows the important fields within the PE optional header and section header for a particular application.

![[Pasted image 20250222235204.png]]

Now, the steps with which we calculate the file execution start offset are followed as below:
- First, determine the Address of entry point from the field under Optional Header.
- Next, check in which section’s virtual space the address of entry point lies.
- Once the right section header is determined, make a note of its virtual address and pointer to raw data fields.

Now, calculate the difference between the address of entry point and the virtual address of the earlier identified section in which the entry point lies.
- Finally, add the difference to the pointer to the raw data which will give the file-based execution start offset of that file.

Now, let be:
- $\Omega \coloneqq Offset\ of\ entry\ point\ in\ EXE\ file$
- $\alpha \coloneqq AddressOfEntryPoint$
- $VA_s \coloneqq .section(VirtualAddress)$
- $\rho_s \coloneqq .section(PointerToRawData)$ 

So, in short the formula for calculating execution start file offset would be:
$$
\Omega = \alpha - VA_s + \rho_s
$$
In this case, the address of entry point lies in the .text section as the .text section starts at 0x00001000 and ends at 0x00007748 and the address of entry point is 0x0000739D.

So, the file offset for the execution start is:  
$$(00000739D_{16} – 00001000_{16}) + 0000400-{16} = 0000679D_{16}$$
#### Difference Between RVA and Offset
##### 1. RVA
RVA is the **memory address relative to the module’s base address** when a program is loaded into memory. It does not include the actual base address but tells how far an address is from it.

For example, if a function is located at `BaseAddress + 0x1000`, its RVA is `0x1000`. This is commonly used in PE (Portable Executable) files to reference locations once the executable is loaded in memory.
##### 2. Offset
Offset is the **distance from the start of a file or structure on disk**. It represents where data is located **inside the file**, rather than in memory.

For example, if a function is stored at `0x1000` within a PE file, its offset is `0x1000`, meaning it's 4096 bytes from the beginning of the file. Offsets are used when analyzing raw binary files.

##### 4. Key Difference
- RVA is used in memory (relative to the base address).
- Offset is used in files (relative to file start).

> Think of RVA as "where it is in memory" and Offset as "where it is in the file."

---
### Introduction to PE Structure
Each executable file share a common format called COFF ([**Common Object File Format**](https://en.wikipedia.org/wiki/COFF)). COFF is used for executables, object code, and shared libraries on Unix-like systems.

And **PE file format** is one such COFF format available today for executable, object code, DLLs, FON font files, and core dumps in 32-bit and 64-bit versions of Windows operating systems.

Several examples of PE file extensions include .exe, .dll, .scr, and .sys, to name just a few.

> [!NOTE]
> In Linux environment we have an **Executable Link FIle (ELF)** format. But for now, we'll focus on Windows.
> 

**PE (Portable Executable) file format** is a data structure that tells the Windows OS loader what information is required to manage the wrapped executable code. This includes dynamic library references for linking, API export, import tables, resource management data, and TLS data.

The data structures on disk are the same data structures used in the memory, and if you know how to find something in a PE file, you can almost certainly find the exact information after the file is loaded into the memory.

It is important to note that PE files are not just mapped into memory as a single memory-mapped file. Instead, the Win32 loader looks at the PE file and decides what portions of the file to map in.

A module in memory represents all the code, data, and resources from an executable file needed by a process.

Other parts of a PE file may be read but not mapped in (for instance, relocations). Some parts may not be mapped in at all, for example, when debug information is placed at the end of the file.

A field in the PE header tells the system how much memory needs to be set aside for mapping the executable into memory. Data that won’t be mapped in is placed at the end of the file, past any parts that will be mapped in.

> Read more at [A Comprehensive Guide To PE Structure, The Layman's Way](https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/)
## References
- [Ring 0x00](https://idafchev.github.io/blog/writing_windows_shellcode/) - Basics of Windows shellcode Writing
- [Red Team Notes](https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode#id-0x1c-into-the-export-table-address-of-exported-functions) - Finding Kernel32 Base and Function Addresses in Shellcode
- [Geek for Geek](https://www.geeksforgeeks.org/thread-in-operating-system/) - Thread in Operating System
- [TechZealots](https://tech-zealots.com/malware-analysis/understanding-concepts-of-va-rva-and-offset/) - Understanding Concepts of Virtual Address (VA), Relative Virtual Address (RVA) and File Offsets
- [TechZealots](https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/) - Introduction to PE Structure
