#Windows #ShellCode

> [!NOTE] 
> This is notes from [Ring 0x00](https://idafchev.github.io/blog/writing_windows_shellcode/) website
### Table of Contents
- [[#Introduction]]
- [[#Thread Local Storage]]
- [[#Find the DLL Base Address]]
- [[#References]]
## Introduction
This tutorial is for `x86 32bit` shellcode. Windows shellcode is a lot harder to write than the shellcode for Linux and you’ll see why. First we need a basic understanding of the Windows architecture, which is shown below. Take a good look at it. Everything above the dividing line is in User mode and everything below is in Kernel mode.

![[Pasted image 20250212202106.png]]

Unlike Linux, in Windows, applications can’t directly accesss system calls. Instead they use functions from the `Windows API (WinAPI)`, which internally call functions from the `Native API (NtAPI)`, which in turn use system calls. The `Native API` functions are undocumented, implemented in `ntdll.dll` and also, as can be seen from the picture above, the lowest level of abstraction for User mode code.

The documented functions from the `Windows API` are stored in `kernel32.dll`, `advapi32.dll`, `gdi32.dll` and others. The base services (like working with file systems, processes, devices, etc.) are provided by `kernel32.dll`.

So to write shellcode for Windows, we’ll need to use functions from `WinAPI` or `NtAPI`. But how do we do that?

`ntdll.dll` and `kernel32.dll` are so important that they are imported by every process.

To demonstrate this I used the tool [ListDlls](https://docs.microsoft.com/en-us/sysinternals/downloads/listdlls) from the [sysinternals suite](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite).

The first four DLLs that are loaded by *explorer.exe*:  

![loaded_dlls1](https://idafchev.github.io/blog/assets/images/windows_shellcode/loaded_dlls1.png)

The first four DLLs that are loaded by *notepad.exe*:  

![loaded_dlls2](https://idafchev.github.io/blog/assets/images/windows_shellcode/loaded_dlls2.png)

I also wrote a little assembly program that does nothing (infinite empty loop) and it has 3 loaded DLLs:  

![loaded_dlls3](https://idafchev.github.io/blog/assets/images/windows_shellcode/loaded_dlls3.png)

Notice the base addresses of the DLLs. They are the same across processes, because they are loaded only once in memory and then referenced with pointer/handle by another process if it needs them. This is done to preserve memory. But those addresses will differ across machines and across reboots.

This means that the shellcode must find where in memory the DLL we’re looking for is located. Then the shellcode must find the address of the exported function, that we’re going to use.

The shellcode I’m going to write is going to be simple and its only function will be to execute `calc.exe`. To accomplish this I’ll make use of the [WinExec](https://msdn.microsoft.com/en-us/library/windows/desktop/ms687393.aspx) function, which has only two arguments and is exported by `kernel32.dll`.
## Thread Local Storage
Before we continue, let's understand what is thread.

A a **thread** refers to a sequence of instructions that can be executed independently by a CPU core. Threads are part of a process, and a single process can have multiple threads running concurrently. Each thread shares the same memory space and resources of the process it belongs to, but it has its own **stack** and **Thread Local Storage (TLS)**.

TLS is a mechanism that allows each thread to have its own private storage for data. This is useful when you want to store data that is specific to a thread and should not be shared with other threads. For example, in a multi-threaded program, each thread might need its own copy of a variable to avoid conflicts or race conditions.

In the context of the **FS segment** (a segment register in x86 architecture), the FS register is often used to point to the base address of the TLS for the current thread. This allows the program to access thread-specific data efficiently.
### Thread in Operation System
A thread is a single sequence stream within a process ([Geek for Geek](https://www.geeksforgeeks.org/thread-in-operating-system/)). Threads are also called  **lightweight processes** as they possess some of the properties of processes. Each thread belongs to exactly one process.
- In an operating system that supports multithreading, the process can consist of many threads. But threads can be effective only if the CPU is more than 1 otherwise two threads have to context switch for that single CPU.
- All threads belonging to the same process share – code section, data section, and OS resources (e.g. open files and signals)
- But each thread has its own (thread control block) – thread ID, program counter, register set, and a stack
- Any operating system process can execute a thread. we can say that single process can have multiple threads.
### Why do We Need Thread?
- Threads run in parallel improving the application performance. Each such thread has its own CPU state and stack, but they share the address space of the process and the environment.
- Threads can share common data so they do not need to use [inter-process communication](https://www.geeksforgeeks.org/inter-process-communication-ipc). Like the processes, threads also have states like ready, executing, blocked, etc. 
- Priority can be assigned to the threads just like the process, and the highest priority thread is scheduled first.
- Each thread has its own [Thread Control Block (TCB)](https://www.geeksforgeeks.org/thread-control-block-in-operating-system). Like the process, a context switch occurs for the thread, and register contents are saved in (TCB). As threads share the same address space and resources, synchronization is also required for the various activities of the thread.
### Components of Threads
These are the basic components of the Operating System:
- **Stack Space:** Stores local variables, function calls, and return addresses specific to the thread.
- **Register Set:** Hold temporary data and intermediate results  for the thread's execution.
- **Program Counter:** Tracks the current instruction being executed by the thread.
### Types of Thread in Operating System
Threads are of two types. These are described below.
- User Level Thread 
- Kernel Level Thread

![[Pasted image 20250216170926.png]]

#### 1. User Level Thread
**User Level Thread** is a type of thread that **is not created using system calls**. The kernel has no role in the management of user-level threads. User-Level threads can be easily implemented by the user. In case when user-level threads are single-threaded processes (processes that has only one thread of execution) kernel-level thread manages them.
##### Advantages of User-Level Threads
- Implementation of the User-Level Thread is easier than Kernel Level Thread.
- [Context Switch](https://www.geeksforgeeks.org/context-switch-in-operating-system) Time is less in User Level Thread.
- User-Level Thread is more efficient than Kernel-Level Thread.
- Because of the presence of only Program Counter, Register Set, and Stack Space, it has a simple representation.
##### Disadvantages of User-Level Threads
- The operating system is unaware of user-level threads, so kernel-level optimizations, like load balancing across CPUs, are not utilized.
- If a user-level thread makes a blocking system call, the entire process (and all its threads) is blocked, reducing efficiency.
- User-level thread scheduling is managed by the application, which can become complex and may not be as optimized as kernel-level scheduling.
#### 2. Kernel Level Threads
A [Kernel Level Thread](https://www.geeksforgeeks.org/kernel-level-threads-in-operating-system) is a type of thread that can recognize the Operating system easily. Kernel Level Threads has its own thread table where it keeps track of the system. The operating System Kernel helps in managing threads. Kernel Threads have somehow longer context switching time. Kernel helps in the management of threads.
##### Advantages of Kernel-Level Threads
- Kernel-level threads can run on multiple processors or cores simultaneously, enabling better utilization of multicore systems.
- The kernel is aware of all threads, allowing it to manage and schedule them effectively across available resources.
- Applications that block frequency are to be handled by the Kernel-Level Threads.
- The kernel can distribute threads across CPUs, ensuring optimal load balancing and system performance.
##### Disadvantages of Kernel-Level Threads
- Context switching between kernel-level threads is slower compared to user-level threads because it requires mode switching between user and kernel space.
- Managing kernel-level threads involves frequent system calls and kernel interactions, leading to increased CPU overhead.
- A large number of threads may overload the kernel scheduler, leading to potential performance degradation in systems with many threads.
- Implementation of this type of thread is a little more complex than a user-level thread.

> For more, refer to the [Difference Between User-Level Thread and Kernel-Level Thread](https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread).
### Difference Between Process and Thread
The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces. Threads are not independent of one another like processes are, and as a result, threads share with other threads their code section, data section, and OS resources (like open files and signals). But, like a process, a thread has its own [program counter (PC)](https://www.geeksforgeeks.org/what-is-program-counter), register set, and stack space.

> For more, refer to [Difference Between Process and Thread](https://www.geeksforgeeks.org/difference-between-process-and-thread).
## Find the DLL Base Address
It's well known that shellcode usually leverages the following chain of internal Windows OS memory structures in order to resolve the kernel32 base address which I am going to walk through in WinDBG:

```
TEB->PEB->Ldr->InMemoryOrderLoadList->currentProgram->ntdll->kernel32.BaseDl
```

One important thing to keep in mind is that _kernel32.dll_ is **always loaded into the same address for all the processes** - regardless if you open a calc.exe, notepad.exe, or any other Windows process. Below shows two different programs - in both cases, the kernel32.dll (and ntdll...) got loaded into the same memory address:

![[Pasted image 20250217012145.png]]

[Thread Environment Block (TEB)](https://en.wikipedia.org/wiki/Win32_Thread_Information_Block) is a structure which is unique for every [[#Thread Local Storage|thread]], resides in memory and holds information about the [[#Thread Local Storage|thread]]. The address of `TEB` is held in the `FS` segment register.

> [!info] What is FS?
>- `FS`is a **segment register** in x86 architecture (use in Intel and AMD CPUs
>- In Windows, the `FS register`point to the **Thread Environment Block (TEB)**, which is a data structure that holds informations about the current thread.
>- It's commonly used to access **thread-specific data**, like **Process Environment Block (PEB)** or **Thread Local Storage (TLS)**.

One of the fields of `TEB` is a pointer to [Process Environment Block (PEB)](https://en.wikipedia.org/wiki/Process_Environment_Block) structure, which holds information about the process. The pointer to `PEB` is `0x30` bytes after the start of `TEB`.

`0x0C` bytes from the start, the `PEB` contains a pointer to [PEB_LDR_DATA](https://www.nirsoft.net/kernel_struct/vista/PEB_LDR_DATA.html) structure, which provides information about the loaded DLLs. It has pointers to three doubly linked lists, two of which are particularly interesting for our purposes:
- `InInitializationOrderModuleList` which holds the DLLs in order of their initialization.
- `InMemoryOrderModuleList` which holds the DLLs in the order they appear in memory.

A pointer to the latter is stored at `0x14` bytes from the start of `PEB_LDR_DATA` structure. The base address of the DLL is stored `0x10` bytes below its list entry connection.

In the pre-Vista Windows versions the first two DLLs in `InInitializationOrderModuleList` were `ntdll.dll` and `kernel32.dll`, but for Vista and onwards the second DLL is changed to `kernelbase.dll`.

The second and the third DLLs in `InMemoryOrderModuleList` are `ntdll.dll` and `kernel32.dll`. This is valid for all Windows versions (at the time of writing (*26/7/2017*)) and is the preferred method, because it’s more portable.

So to find the address of `kernel32.dll` we must traverse several in-memory structures. The steps to do so are:
1. Get address of `PEB` with `fs:0x30`
2. Get address of `PEB_LDR_DATA` ([[Data#^offsetAddr|offset]] `0x0C`)
3. Get address of the first list entry in the `InMemoryOrderModuleList` (offset `0x14`)
    (At this point is important to note that each entry in this list contain a pointer to the next entry)
4. Get address of the second (`ntdll.dll`) list entry in the `InMemoryOrderModuleList` (offset `0x00`)
5. Get address of the third (`kernel32.dll`) list entry in the `InMemoryOrderModuleList` (offset `0x00`)
6. Get the base address of `kernel32.dll` (offset `0x10`)

The assembly to do this is:

``` nasm
mov eax, fs:0x30	   ; 1. Get pointer to PEB
mov eax, [eax + 0x0C]  ; 2. Get pointer to PEB_LDR_DATA
mov eax, [eax + 0x14]  ; 3. Get pointer to first entry in InMemoryOrderModuleList
mov eax, [eax]		   ; 4. Get pointer to second (ntdll.dll) entry in InMemoryOrderModuleList
mov eax, [eax]		   ; 5. Get pointer to third (kernel32.dll) entry in InMemoryOrderModuleList
mov eax, [eax + 0x10]  ; 6. Get kernel32.dll base address
```

> [!question] Understanding the First Line
> - `mov eax, fs:0x30` loads the **Process Environment Block (PEB) pointer** into `eax`.   
> - In **Windows user-mode applications**, the **Thread Information Block (TIB)** (also called the **Thread Environment Block, TEB**) is located at `fs:[0]`.
> - The colon `:` specifies a segment override, meaning "read from the `fs` segment at offset `0x30`"
> ###### Why use `fs` insted `ds`?
> The reason why `fs` is used instead of `ds` (the default data segment) is because **Windows uses the FS segment register to store thread-specific information**, including the **Thread Environment Block (TEB)**, which contains a pointer to the **Process Environment Block (PEB)**.

They say a picture is worth a thousand words, so I made onde to illustrate the process. You can also access it using that [link](https://idafchev.github.io/blog/assets/images/windows_shellcode/locate_dll.png) to better view

![[Pasted image 20250216213344.png]]

If a picture is worth a thousand words, then an animation is worth $|(number\_of\_frames \times 1000) \times words$. 

![[locate_dll1.gif]]
[link](https://idafchev.github.io/blog/assets/images/windows_shellcode/locate_dll1.gif)

![[locate_dll2.gif]]
[link](https://idafchev.github.io/blog/assets/images/windows_shellcode/locate_dll2.gif)
## Find the Function Address
### PE Executable

## References
- [Ring 0x00](https://idafchev.github.io/blog/writing_windows_shellcode/) - Basics of Windows shellcode Writing
- [Red Team Notes](https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode#id-0x1c-into-the-export-table-address-of-exported-functions) - Finding Kernel32 Base and Function Addresses in Shellcode
- [Geek for Geek](https://www.geeksforgeeks.org/thread-in-operating-system/) - Thread in Operating System

