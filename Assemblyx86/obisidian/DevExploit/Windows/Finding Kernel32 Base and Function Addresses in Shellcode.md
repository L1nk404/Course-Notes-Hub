#Windows #Kernel32 #BaseAddress

## Intro

The purpose of this lab is to understand how shellcode finds kernel32 base address in memory of the process it's running in and then uses to find addresses of other functions that it requires in order to achieve its goal.

In this lab I will write some assembly to find the kernel32 dll's base address, resolve `WinExec` function address in memory and call it to open `calc.exe`

> [!NOTE] 
> This is just a copy with a few notes added from this [article]( https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode#id-0x1c-into-the-export-table-address-of-exported-functions). 
## Finding Kernel32 Base Address
It's well known that shellcode usually leverages the following chain of internal Windows OS memory structures in order to resolve the kernel32 base address which I am going to walk through in WinDBG:

```
TEB->PEB->Ldr->InMemoryOrderLoadList->currentProgram->ntdll->kernel32.BaseDl
```

>  Don't worry, will see details of the structure bellow.

One important thing to keep in mind is that *kernel32.dll* is **always loaded into the same address for all the processes** - regardless if you open a calc.exe, notepad.exe, or any other Windows process. Below shows my program for this lab on the left and another random program on the right - in both cases, the kernel32.dll (and ntdll...) got loaded into the same memory address:

![](https://www.ired.team/~gitbook/image?url=https%3A%2F%2F386337598-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LFEMnER3fywgFHoroYn%252F-LjkLx3pApbX0ud-TlWE%252F-LjkO03Sd-6WfDgASDH2%252Fimage.png%3Falt%3Dmedia%26token%3D6e996177-14f1-4ad7-b46b-504285a655a6&width=768&dpr=4&quality=100&sign=b20b9b0&sv=2)
### Structure
The first important OS structure of the chain is called a **Thread Environment Block** (**TEB**) which contains information about the process's thread, including one member that is a pointer to another very important structure called **Process Environment Block** (**PEB, offset 0x30**) where information about the process itself (image path, commandline arguments, loaded modules and similar) is stored:

```
dt _teb
``` 

![[Pasted image 20250212151902.png]]

Inside the `PEB` structure, there is a member `Ldr` which points to a `PEB_LDR_DATA` structure (offset 0x00c):

```
dt_peb
```

![[Pasted image 20250212152113.png]]

`PEB_LDR_DATA` contains a pointer to `InMemoryOrderModuleList` (offset 0x14) that contains information about the modules that were loaded in the process:

```
dt_PEB_LDR_DATA
```

![[Pasted image 20250212152232.png]]

`InMemoryOrderModuleList` points to another structure we're interested in - `LDR_DATA_TABLE_ENTRY` even though WinDBG suggests the structure type is `LIST_ENTRY`. As confusing as it may seem at first, this is actually right, since `InMemoryOrderModuleList` is a doubly linked list where each list item points to an `LDR_DATA_TABLE_ENTRY` structure.

> [!important] Remember
>  Since the shellcode is looking for the kernel32.dll base address, the `LDR_DATA_TABLE_ENTRY` is the last structure in the chain of structures it needs to locate. Once the structure is located, the member `DllBase` at offset 0x18 stores the base address of the module:

```
dt _LDR_DATA_TABLE_ENTRY
```

![[Pasted image 20250212152645.png]]

## Initialized Structures

Let's now repeat the same exercise as above, but this time using real memory addresses so we can see how those memory structures look like in a real process with real data. Let's check the `PEB` and note the `Ldr` pointer (77de0c40):

```
!peb
```





